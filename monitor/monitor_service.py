#!/usr/bin/env python3
"""
============================================================================
Solana Address Monitoring Service
============================================================================
Description: Local Flask service that receives Solana addresses from
             AutoHotkey script and stores them for Telegram monitoring
Author: Generated by Claude Code
Version: 1.0 (Phase 1 - MVP)
============================================================================
"""

from flask import Flask, request, jsonify, render_template, send_file
from datetime import datetime
import json
import os
import re
import uuid
from threading import Thread
import csv
import io

app = Flask(__name__)

# Configuration
DATA_FILE = "monitored_addresses.json"
ANALYSIS_RESULTS_DIR = "analysis_results"
DEFAULT_THRESHOLD = 100  # Default SOL threshold for notifications

# Helius API key (read from environment or config file)
# Set via environment variable: set HELIUS_API_KEY=your-key-here
# Or create config.json with {"helius_api_key": "your-key-here"}
def load_api_key():
    """Load Helius API key from environment or config file"""
    # Try environment variable first
    api_key = os.environ.get('HELIUS_API_KEY')
    if api_key:
        return api_key

    # Try config.json
    config_file = 'config.json'
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                return config.get('helius_api_key')
        except Exception as e:
            print(f"âš  Error loading config.json: {e}")

    print("âš  WARNING: No Helius API key found!")
    print("   Set HELIUS_API_KEY environment variable or create config.json")
    print("   Example config.json: {\"helius_api_key\": \"your-key-here\"}")
    return None

HELIUS_API_KEY = load_api_key()

# In-memory storage (backed by JSON file)
monitored_addresses = {}
analysis_jobs = {}  # job_id -> {status, result, error}

# Import Helius API
try:
    from helius_api import TokenAnalyzer
    helius_enabled = True
    print("âœ“ Helius API module loaded")
except ImportError as e:
    helius_enabled = False
    print(f"âš  Helius API not available: {e}")


def load_addresses():
    """Load monitored addresses from JSON file"""
    global monitored_addresses
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r') as f:
                monitored_addresses = json.load(f)
            print(f"âœ“ Loaded {len(monitored_addresses)} monitored addresses from {DATA_FILE}")
        except Exception as e:
            print(f"âš  Error loading addresses: {e}")
            monitored_addresses = {}
    else:
        monitored_addresses = {}
        print(f"âš  No existing data file found. Starting fresh.")


def save_addresses():
    """Save monitored addresses to JSON file"""
    try:
        with open(DATA_FILE, 'w') as f:
            json.dump(monitored_addresses, f, indent=2)
        return True
    except Exception as e:
        print(f"âš  Error saving addresses: {e}")
        return False


def is_valid_solana_address(address):
    """
    Validate Solana address format
    - Must be 32-44 characters
    - Must only contain base58 characters (no 0, O, I, l)
    """
    if not address or not isinstance(address, str):
        return False

    # Length check
    if len(address) < 32 or len(address) > 44:
        return False

    # Base58 character check (excludes 0, O, I, l)
    base58_pattern = r'^[1-9A-HJ-NP-Za-km-z]+$'
    if not re.match(base58_pattern, address):
        return False

    return True


@app.route('/register', methods=['POST'])
def register_address():
    """
    Register a new Solana address for monitoring

    Expected JSON payload:
    {
        "address": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        "timestamp": "20250101120000"  # optional
    }
    """
    try:
        data = request.get_json()

        if not data:
            return jsonify({"error": "No JSON data provided"}), 400

        address = data.get('address', '').strip()

        # Validate address
        if not is_valid_solana_address(address):
            return jsonify({"error": "Invalid Solana address format"}), 400

        # Check if already registered
        if address in monitored_addresses:
            return jsonify({
                "status": "already_registered",
                "message": f"Address already being monitored",
                "address": address,
                "registered_at": monitored_addresses[address]['registered_at']
            }), 200

        # Add new address with optional note
        note = data.get('note', '').strip() if data.get('note') else None

        monitored_addresses[address] = {
            "address": address,
            "registered_at": datetime.now().isoformat(),
            "threshold": DEFAULT_THRESHOLD,
            "total_notifications": 0,
            "last_notification": None,
            "note": note
        }

        # Save to file
        if save_addresses():
            print(f"âœ“ Registered new address: {address}")
            return jsonify({
                "status": "success",
                "message": "Address registered for monitoring",
                "address": address,
                "threshold": DEFAULT_THRESHOLD,
                "total_monitored": len(monitored_addresses)
            }), 201
        else:
            return jsonify({"error": "Failed to save address"}), 500

    except Exception as e:
        print(f"âš  Error in /register: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/addresses', methods=['GET'])
def list_addresses():
    """List all monitored addresses"""
    return jsonify({
        "total": len(monitored_addresses),
        "addresses": list(monitored_addresses.values())
    }), 200


@app.route('/address/<address>', methods=['GET'])
def get_address(address):
    """Get details for a specific address"""
    if address in monitored_addresses:
        return jsonify(monitored_addresses[address]), 200
    else:
        return jsonify({"error": "Address not found"}), 404


@app.route('/address/<address>', methods=['DELETE'])
def remove_address(address):
    """Remove an address from monitoring"""
    if address in monitored_addresses:
        del monitored_addresses[address]
        save_addresses()
        print(f"âœ“ Removed address: {address}")
        return jsonify({
            "status": "success",
            "message": "Address removed from monitoring",
            "address": address
        }), 200
    else:
        return jsonify({"error": "Address not found"}), 404


@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        "status": "running",
        "monitored_addresses": len(monitored_addresses),
        "timestamp": datetime.now().isoformat()
    }), 200


@app.route('/address/<address>/note', methods=['PUT'])
def update_note(address):
    """Update note/tag for an address"""
    if address not in monitored_addresses:
        return jsonify({"error": "Address not found"}), 404

    try:
        data = request.get_json()
        note = data.get('note', '').strip() if data.get('note') else None

        monitored_addresses[address]['note'] = note
        save_addresses()
        print(f"âœ“ Updated note for address: {address}")

        return jsonify({
            "status": "success",
            "message": "Note updated successfully",
            "address": address,
            "note": note
        }), 200

    except Exception as e:
        print(f"âš  Error updating note: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/import', methods=['POST'])
def import_addresses():
    """Import addresses from backup file"""
    try:
        data = request.get_json()
        imported = data.get('addresses', [])

        if not isinstance(imported, list):
            return jsonify({"error": "Invalid import format"}), 400

        added = 0
        skipped = 0

        for addr_data in imported:
            if isinstance(addr_data, dict):
                address = addr_data.get('address')
                if address and is_valid_solana_address(address):
                    if address not in monitored_addresses:
                        monitored_addresses[address] = {
                            "address": address,
                            "registered_at": addr_data.get('registered_at', datetime.now().isoformat()),
                            "threshold": addr_data.get('threshold', DEFAULT_THRESHOLD),
                            "total_notifications": addr_data.get('total_notifications', 0),
                            "last_notification": addr_data.get('last_notification'),
                            "note": addr_data.get('note')
                        }
                        added += 1
                    else:
                        skipped += 1

        save_addresses()
        print(f"âœ“ Imported {added} addresses ({skipped} skipped as duplicates)")

        return jsonify({
            "status": "success",
            "message": f"Imported {added} addresses ({skipped} duplicates skipped)",
            "added": added,
            "skipped": skipped,
            "total": len(monitored_addresses)
        }), 200

    except Exception as e:
        print(f"âš  Error importing addresses: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/clear', methods=['POST'])
def clear_all():
    """Clear all monitored addresses (use with caution!)"""
    global monitored_addresses
    count = len(monitored_addresses)
    monitored_addresses = {}
    save_addresses()
    print(f"âš  Cleared all {count} monitored addresses")
    return jsonify({
        "status": "success",
        "message": f"Cleared {count} addresses",
        "total_monitored": 0
    }), 200


# ============================================================================
# Token Analysis Endpoints
# ============================================================================

def run_token_analysis(job_id, token_address, min_usd, time_window_hours):
    """Background worker function to analyze a token"""
    try:
        print(f"[Job {job_id}] Starting analysis for {token_address}")
        analysis_jobs[job_id]['status'] = 'processing'

        analyzer = TokenAnalyzer(HELIUS_API_KEY)
        result = analyzer.analyze_token(
            mint_address=token_address,
            min_usd=min_usd,
            time_window_hours=time_window_hours
        )

        # Convert datetime objects to strings for JSON serialization
        for bidder in result.get('early_bidders', []):
            if 'first_buy_time' in bidder and hasattr(bidder['first_buy_time'], 'isoformat'):
                bidder['first_buy_time'] = bidder['first_buy_time'].isoformat()

        # Save result to file
        os.makedirs(ANALYSIS_RESULTS_DIR, exist_ok=True)
        result_file = os.path.join(ANALYSIS_RESULTS_DIR, f"{job_id}.json")
        with open(result_file, 'w') as f:
            json.dump(result, f, indent=2)

        analysis_jobs[job_id]['status'] = 'completed'
        analysis_jobs[job_id]['result'] = result
        analysis_jobs[job_id]['completed_at'] = datetime.now().isoformat()

        print(f"[Job {job_id}] Analysis complete - found {result['total_unique_buyers']} early bidders")

    except Exception as e:
        print(f"[Job {job_id}] Analysis failed: {str(e)}")
        analysis_jobs[job_id]['status'] = 'failed'
        analysis_jobs[job_id]['error'] = str(e)


@app.route('/analyze/token', methods=['POST'])
def analyze_token():
    """
    Analyze a token to find early bidders

    Expected JSON payload:
    {
        "address": "TokenMintAddress...",
        "min_usd": 50,  # optional, default 50
        "time_window_hours": 24  # optional, default 24
    }
    """
    if not helius_enabled:
        return jsonify({
            "error": "Helius API not available. Install dependencies: pip install requests solana base58"
        }), 503

    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400

        token_address = data.get('address', '').strip()

        if not is_valid_solana_address(token_address):
            return jsonify({"error": "Invalid Solana address format"}), 400

        # Get analysis parameters
        min_usd = float(data.get('min_usd', 50))
        time_window_hours = int(data.get('time_window_hours', 24))

        # Create analysis job
        job_id = str(uuid.uuid4())[:8]
        analysis_jobs[job_id] = {
            'job_id': job_id,
            'token_address': token_address,
            'status': 'queued',
            'min_usd': min_usd,
            'time_window_hours': time_window_hours,
            'created_at': datetime.now().isoformat(),
            'result': None,
            'error': None
        }

        # Start background analysis
        thread = Thread(target=run_token_analysis, args=(job_id, token_address, min_usd, time_window_hours))
        thread.daemon = True
        thread.start()

        print(f"âœ“ Queued token analysis: {token_address} (Job ID: {job_id})")

        return jsonify({
            'status': 'queued',
            'job_id': job_id,
            'token_address': token_address,
            'min_usd': min_usd,
            'time_window_hours': time_window_hours,
            'results_url': f'/analysis/{job_id}'
        }), 202

    except Exception as e:
        print(f"âš  Error in /analyze/token: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/analysis/<job_id>', methods=['GET'])
def get_analysis(job_id):
    """Get analysis results by job ID"""
    if job_id not in analysis_jobs:
        return jsonify({"error": "Job not found"}), 404

    job = analysis_jobs[job_id]

    # If completed, ensure result is loaded
    if job['status'] == 'completed' and job['result'] is None:
        try:
            result_file = os.path.join(ANALYSIS_RESULTS_DIR, f"{job_id}.json")
            with open(result_file, 'r') as f:
                job['result'] = json.load(f)
        except Exception as e:
            job['status'] = 'failed'
            job['error'] = f"Could not load results: {str(e)}"

    return jsonify(job), 200


@app.route('/analysis/<job_id>/csv', methods=['GET'])
def export_analysis_csv(job_id):
    """Export analysis results as CSV"""
    if job_id not in analysis_jobs:
        return jsonify({"error": "Job not found"}), 404

    job = analysis_jobs[job_id]

    if job['status'] != 'completed' or not job.get('result'):
        return jsonify({"error": "Analysis not completed or no results"}), 400

    try:
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)

        # Write header
        writer.writerow(['Wallet Address', 'First Buy Time', 'Total USD', 'Transaction Count', 'Average Buy USD'])

        # Write data
        for bidder in job['result'].get('early_bidders', []):
            writer.writerow([
                bidder['wallet_address'],
                bidder['first_buy_time'],
                f"${bidder['total_usd']:.2f}",
                bidder['transaction_count'],
                f"${bidder['average_buy_usd']:.2f}"
            ])

        # Prepare response
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8')),
            mimetype='text/csv',
            as_attachment=True,
            download_name=f'token_analysis_{job_id}.csv'
        )

    except Exception as e:
        return jsonify({"error": f"CSV export failed: {str(e)}"}), 500


@app.route('/analysis/<job_id>/results', methods=['GET'])
def view_analysis_results(job_id):
    """View analysis results in HTML"""
    if job_id not in analysis_jobs:
        return "Job not found", 404

    job = analysis_jobs[job_id]
    return render_template('analysis_results.html', job=job)


@app.route('/analysis', methods=['GET'])
def list_analyses():
    """List all analysis jobs"""
    return jsonify({
        'total': len(analysis_jobs),
        'jobs': list(analysis_jobs.values())
    }), 200


# ============================================================================
# Dashboard Routes
# ============================================================================

@app.route('/')
def dashboard():
    """Serve web dashboard"""
    return render_template('dashboard.html')


if __name__ == '__main__':
    print("=" * 70)
    print("Solana Address Monitoring Service")
    print("=" * 70)
    print(f"Starting Flask server on http://localhost:5001")
    print(f"Data file: {DATA_FILE}")
    print(f"Default threshold: {DEFAULT_THRESHOLD} SOL")
    print("-" * 70)

    # Load existing addresses
    load_addresses()

    print("-" * 70)
    print("Available endpoints:")
    print("  GET    /                           - Web Dashboard")
    print("  POST   /register                   - Register new address")
    print("  GET    /addresses                  - List all addresses")
    print("  GET    /address/<addr>             - Get address details")
    print("  DELETE /address/<addr>             - Remove address")
    print("  PUT    /address/<addr>/note        - Update address note")
    print("  POST   /import                     - Import addresses from backup")
    print("  GET    /health                     - Health check")
    print("  POST   /clear                      - Clear all addresses")
    print()
    print("  POST   /analyze/token              - Analyze token for early bidders")
    print("  GET    /analysis                   - List all analysis jobs")
    print("  GET    /analysis/<job_id>          - Get analysis status/results")
    print("  GET    /analysis/<job_id>/results  - View results in browser")
    print("  GET    /analysis/<job_id>/csv      - Export results as CSV")
    print("-" * 70)
    if helius_enabled:
        print("âœ“ Helius API enabled - Token analysis ready")
    else:
        print("âš  Helius API disabled - Run: pip install requests solana base58")
    print("-" * 70)
    print("\nðŸ“Š Open http://localhost:5001 in your browser to access the dashboard")
    print("Press Ctrl+C to stop the server")
    print("=" * 70)
    print()

    # Run server
    app.run(host='localhost', port=5001, debug=False)