; ============================================================================
; Solscan Hotkey Script
; ============================================================================
; Description: Click side mouse button over a Solana address to open Solscan
; Author: Generated by Claude Code
; Version: 3.0 (AutoHotkey v2) - Wheel Menu Edition
;
; Recent changes:
; - F13 now opens radial wheel menu with all actions
; - Mouse gesture or keyboard (1-6) selection
; - Visual feedback with real-time hover states
; - All existing hotkeys still work as direct shortcuts
; ============================================================================

#Requires AutoHotkey v2.0
#SingleInstance Force
SetWorkingDir A_ScriptDir
SendMode "Input"
CoordMode "Mouse", "Screen"

; Configuration
NOTIFICATION_DURATION := 2000  ; milliseconds
SELECTION_DELAY := 100         ; delay after selection before copy
LOCAL_SERVER_URL := "http://localhost:5001/register"  ; Telegram monitor service

; Legacy global variables (kept for F14 backward compatibility)
global currentMainAddress := ""
global excludedAddressesList := []

; ============================================================================
; MAIN HOTKEY: F14 (mapped from your mouse button in G HUB)
; ============================================================================
; Opens Solana address in Solscan with filters
; Hover over address + click the button you mapped to F14
; ============================================================================

F14::HandleSolscanLookup()

; ============================================================================
; WHEEL MENU HOTKEY: F13 (mapped from your mouse button in G HUB)
; ============================================================================
; Opens radial wheel menu with all available actions
; Click the button you mapped to F13 to open menu
; Select action by: moving mouse toward it, or pressing number key (1-6)
; ============================================================================

F13::ShowWheelMenu()

; ============================================================================
; TELEGRAM MONITOR HOTKEY: Ctrl+F14
; ============================================================================
; Register address for Telegram monitoring of large transfers
; Hold Ctrl + click the button you mapped to F14
; ============================================================================

^F14::HandleTelegramRegister()

; ============================================================================
; DEFINED.FI LOOKUP HOTKEY: F15
; ============================================================================
; Open Solana token on defined.fi with automatic search
; Hover over token address + press F15
; Requires Tampermonkey UserScript for reliable search automation
; ============================================================================

F15::HandleDefinedFiLookup()

; ============================================================================
; TOKEN ANALYSIS HOTKEY: F16
; ============================================================================
; Analyze token for early bidders (requires monitor service + Helius API)
; Hover over token address + press F16
; Results available at http://localhost:5001/analysis
; ============================================================================

F16::HandleTokenAnalysis()

; ============================================================================
; Core Function: Capture text and open Solscan
; ============================================================================

HandleSolscanLookup() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Store this as the current main address and reset exclusions
            global currentMainAddress := address
            global excludedAddressesList := []

            OpenSolscan(address)
            ShowNotification("Opening Solscan...", address)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Core Function: Capture text and open Solscan WITH EXCLUDE FILTER
; ============================================================================

HandleSolscanLookupWithExclude() {
    ; IMPORTANT: Capture text FIRST before doing any navigation
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor (same as F14)
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; NOW get the current URL and parse both address and existing exclusions
    urlData := GetAddressAndExclusionsFromURL()
    currentAddress := urlData.address
    existingExclusions := urlData.exclusions

    ; Validate we're on a Solscan page
    if (currentAddress == "") {
        ShowNotification("No Solscan page detected", "Open a Solscan address page first")
        return
    }

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        addressToExclude := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (addressToExclude == "" && IsValidSolanaAddress(capturedText)) {
            addressToExclude := capturedText
        }

        ; Validate the address to exclude
        if (addressToExclude != "" && IsValidSolanaAddress(addressToExclude)) {
            ; Check if already excluded
            alreadyExcluded := false
            for index, addr in existingExclusions {
                if (addr == addressToExclude) {
                    alreadyExcluded := true
                    break
                }
            }

            if (!alreadyExcluded) {
                existingExclusions.Push(addressToExclude)
            }

            ; Reload the current page with updated exclusions
            ReloadPageWithExclusions(currentAddress, existingExclusions)
            ShowNotification("Excluded address added", addressToExclude)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Text Capture Logic
; ============================================================================

CaptureTextUnderCursor() {
    ; Strategy 1: Check if text is already selected
    Send "^c"
    if ClipWait(0.2) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; Strategy 2: Double-click to select word under cursor
    Click
    Sleep 50
    Click
    Sleep SELECTION_DELAY

    ; Copy selected text
    Send "^c"
    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            captured := Trim(A_Clipboard)
            return captured
        }
    }

    ; Strategy 3: Select entire line (fallback)
    Send "{Home}"
    Send "+{End}"
    Sleep SELECTION_DELAY
    Send "^c"
    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return A_Clipboard
        }
    }

    return ""
}

; ============================================================================
; Text Capture for Exclusion (Selection-Based Only)
; ============================================================================
; This function ONLY captures pre-selected text to avoid any mouse clicks
; User must manually select/highlight the address before pressing XButton1

CaptureTextWithoutClicking() {
    ; Only try to copy already-selected text
    ; No mouse clicking or automatic selection
    A_Clipboard := ""
    Send "^c"

    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; If nothing was selected, return empty
    ; User needs to manually select the address first
    return ""
}

; ============================================================================
; Validation: Solana Address Pattern
; ============================================================================

IsValidSolanaAddress(text) {
    ; Remove whitespace and quotes
    text := Trim(text)
    text := StrReplace(text, "`r", "")
    text := StrReplace(text, "`n", "")
    text := StrReplace(text, " ", "")
    text := StrReplace(text, '"', "")
    text := StrReplace(text, "'", "")

    ; Solana addresses are base58 encoded, 32-44 characters
    length := StrLen(text)
    if (length < 32 || length > 44) {
        return false
    }

    ; Check if all characters are valid base58 (excludes 0, O, I, l)
    Loop Parse, text
    {
        char := A_LoopField
        ; Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
        if !RegExMatch(char, "[1-9A-HJ-NP-Za-km-z]") {
            return false
        }
    }

    return true
}

; ============================================================================
; Helper: Extract address from longer text
; ============================================================================

ExtractAddressFromText(text) {
    ; Try to find a base58 string of correct length
    if RegExMatch(text, "[1-9A-HJ-NP-Za-km-z]{32,44}", &match) {
        return match[0]
    }
    return ""
}

; ============================================================================
; Helper: Get address and exclusions from current browser URL (Combined)
; ============================================================================
; IMPORTANT: This function depends on Solscan's URL structure
;
; URL Structure Dependencies (as of 2025):
; -----------------------------------------
; 1. Main address format:
;    https://solscan.io/account/{ADDRESS}?params...
;    Regex: "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})"
;
; 2. Exclusion parameter format:
;    &to_address=!Addr1,!Addr2,!Addr3
;    - Parameter name: "to_address"
;    - Exclusion prefix: "!" (exclamation mark)
;    - Separator: "," (comma)
;    - URL encoded: %21 for !, %2C for comma (case insensitive)
;    Regex: "to_address=([^&]+)"
;
; If Solscan changes their URL structure, update the following:
; - Line ~306: Main address regex pattern
; - Line ~312: Exclusion parameter name
; - Line ~316: Exclusion prefix character
; - Line ~319: Separator character
;
; Fallback behavior if parsing fails:
; - result.address will be "" (empty string)
; - result.exclusions will be [] (empty array)
; - Script will show "No Solscan page detected" notification
; ============================================================================

GetAddressAndExclusionsFromURL() {
    ; Get the current browser URL by copying it from the address bar
    ; Save clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Select address bar (Ctrl+L works in most browsers)
    Send "^l"
    Sleep 100

    ; Copy URL
    Send "^c"
    Sleep 100

    ; Get URL from clipboard
    currentURL := A_Clipboard

    ; Restore clipboard
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Press Escape to deselect address bar
    Send "{Escape}"

    ; Create result object
    result := {address: "", exclusions: []}

    ; Extract address from Solscan URL
    ; Format: https://solscan.io/account/ADDRESS...
    ; UPDATE THIS if Solscan changes their URL pattern
    if RegExMatch(currentURL, "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})", &match) {
        result.address := match[1]
    }

    ; Parse existing exclusions from to_address parameter
    ; Format: to_address=!Addr1,!Addr2 or to_address=%21Addr1,%21Addr2 or %21Addr1%2C%21Addr2
    ; UPDATE THIS if Solscan changes their parameter name or format
    if RegExMatch(currentURL, "to_address=([^&]+)", &match) {
        excludeParam := match[1]

        ; URL decode common characters
        ; UPDATE THIS if Solscan changes encoding
        excludeParam := StrReplace(excludeParam, "%21", "!")  ; ! (exclamation)
        excludeParam := StrReplace(excludeParam, "%2C", ",")  ; , (comma)
        excludeParam := StrReplace(excludeParam, "%2c", ",")  ; , (comma lowercase)

        ; Split by comma to get individual exclusions
        ; UPDATE THIS if Solscan changes separator
        Loop Parse, excludeParam, ","
        {
            address := A_LoopField
            ; Remove the ! prefix
            ; UPDATE THIS if Solscan changes exclusion prefix
            if (SubStr(address, 1, 1) == "!") {
                address := SubStr(address, 2)
            }
            ; Validate and add to list
            if (address != "" && IsValidSolanaAddress(address)) {
                result.exclusions.Push(address)
            }
        }
    }

    return result
}

; ============================================================================
; Action: Open Solscan in Browser
; ============================================================================

OpenSolscan(address) {
    ; Custom Solscan URL with your preferred filters
    url := "https://solscan.io/account/" . address . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value=&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"
    Run url
}

; ============================================================================
; Action: Reload Page with Exclusions (URL-Based, Per-Tab Persistence)
; ============================================================================
; IMPORTANT: This function builds Solscan URLs with exclusion filters
;
; If Solscan changes their URL structure, update the following:
; - Line ~400: Parameter name "to_address"
; - Line ~392: Exclusion prefix "!"
; - Line ~389: Separator character ","
; - Line ~397-403: Base URL and all other parameters
; ============================================================================

ReloadPageWithExclusions(mainAddress, exclusionsList) {
    ; Build the exclusion parameter from the list
    ; Format: to_address=!Address1,!Address2,!Address3
    ; UPDATE THIS if Solscan changes format
    excludeParam := ""

    for index, excludeAddr in exclusionsList {
        if (excludeAddr != "") {
            if (excludeParam != "") {
                excludeParam .= ","  ; UPDATE THIS if separator changes
            }
            excludeParam .= "!" . excludeAddr  ; UPDATE THIS if prefix changes
        }
    }

    ; Build URL with exclusion filter
    ; UPDATE THIS entire URL structure if Solscan redesigns
    ; IMPORTANT: Match parameter order from OpenSolscan() to avoid Solscan parsing issues
    url := "https://solscan.io/account/" . mainAddress . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value="

    ; Insert to_address BEFORE token_address (same as OpenSolscan)
    if (excludeParam != "") {
        url .= "&to_address=" . excludeParam  ; UPDATE THIS parameter name if changed
    }

    url .= "&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"

    ; Copy URL to clipboard
    A_Clipboard := url
    Sleep 100  ; Give clipboard time to update

    ; Focus browser and navigate to URL using address bar
    ; Ctrl+L selects address bar in most browsers
    Send "^l"
    Sleep 100
    ; Paste the URL
    Send "^v"
    Sleep 100
    ; Press Enter to navigate
    Send "{Enter}"
}

; ============================================================================
; Telegram Monitor: Register Address for Monitoring
; ============================================================================

HandleTelegramRegister() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and register for monitoring
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to local monitoring service
            RegisterAddressWithMonitor(address)
        } else {
            ShowNotification("Invalid address", "Cannot register for monitoring")
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

RegisterAddressWithMonitor(address) {
    ; Build JSON payload
    jsonData := '{"address":"' . address . '","timestamp":"' . A_Now . '"}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_register.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to local server
    command := 'curl -X POST "' . LOCAL_SERVER_URL . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ShowNotification("Monitoring registered", address)
        } else {
            ShowNotification("Monitor service offline", "Start Python service first")
        }
    } catch {
        ShowNotification("Monitor service offline", "Start Python service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; Defined.fi Lookup: Open Token on defined.fi with Auto-Search
; ============================================================================

HandleDefinedFiLookup() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open defined.fi
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Open defined.fi with hash parameter for UserScript to handle
            url := "https://defined.fi/#autosearch=" . address
            Run url
            ShowNotification("Opening defined.fi", address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

; ============================================================================
; Token Analysis: Analyze token for early bidders using Helius API
; ============================================================================

HandleTokenAnalysis() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and analyze
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to analysis service
            AnalyzeTokenWithService(address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

AnalyzeTokenWithService(tokenAddress) {
    ; Build JSON payload
    jsonData := '{"address":"' . tokenAddress . '","min_usd":50,"time_window_hours":24}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_analyze.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to analysis endpoint
    analysisUrl := "http://localhost:5001/analyze/token"
    command := 'curl -X POST "' . analysisUrl . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ShowNotification("Analysis queued", "View results at localhost:5001")
            ; Optionally open browser to results
            Run "http://localhost:5001/analysis"
        } else {
            ShowNotification("Analysis service offline", "Start monitor service first")
        }
    } catch {
        ShowNotification("Analysis service offline", "Start monitor service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; UI Feedback: Toast Notification
; ============================================================================

ShowNotification(title, message) {
    ToolTip title . "`n" . message
    SetTimer () => ToolTip(), -NOTIFICATION_DURATION
}

; ============================================================================
; WHEEL MENU SYSTEM
; ============================================================================
; Radial menu that shows all available actions
; User can select by moving mouse toward an action or pressing number keys
; ============================================================================

; Wheel menu configuration
global WheelMenuActive := false
global WheelMenuGui := ""
global WheelMenuStartX := 0
global WheelMenuStartY := 0
global WheelMenuSelectedAction := 0
global WheelMenuTimer := ""
global WheelMenuButtons := Map()

; Menu actions configuration
global WheelMenuActions := [
    {id: 1, name: "Open Solscan", key: "1", handler: "HandleSolscanLookup", color: "4A90E2"},
    {id: 2, name: "Add Exclusion", key: "2", handler: "HandleSolscanLookupWithExclude", color: "E74C3C"},
    {id: 3, name: "Monitor Address", key: "3", handler: "HandleTelegramRegister", color: "9B59B6"},
    {id: 4, name: "Defined.fi Lookup", key: "4", handler: "HandleDefinedFiLookup", color: "2ECC71"},
    {id: 5, name: "Analyze Token", key: "5", handler: "HandleTokenAnalysis", color: "F39C12"},
    {id: 6, name: "Cancel", key: "Esc", handler: "", color: "95A5A6"}
]

ShowWheelMenu() {
    global WheelMenuActive, WheelMenuGui, WheelMenuStartX, WheelMenuStartY
    global WheelMenuSelectedAction, WheelMenuTimer, WheelMenuButtons, WheelMenuActions

    ; If menu is already active, close it
    if (WheelMenuActive) {
        CloseWheelMenu()
        return
    }

    ; Store initial mouse position
    MouseGetPos &WheelMenuStartX, &WheelMenuStartY

    ; Create GUI overlay
    WheelMenuGui := Gui("+AlwaysOnTop -Caption +ToolWindow +Owner")
    WheelMenuGui.BackColor := "1a1a1a"
    WheelMenuGui.SetFont("s11 Bold", "Segoe UI")

    ; Menu dimensions
    centerSize := 120
    buttonWidth := 180
    buttonHeight := 50
    radius := 150

    ; Center position relative to GUI (not screen)
    menuSize := 500
    centerX := menuSize // 2
    centerY := menuSize // 2

    ; Calculate button positions in a circle
    numActions := WheelMenuActions.Length
    angleStep := 360 / numActions

    WheelMenuButtons := Map()

    ; Create buttons positioned in a circle
    for index, action in WheelMenuActions {
        ; Calculate angle (start from top, go clockwise)
        angle := (index - 1) * angleStep - 90  ; -90 to start at top
        angleRad := angle * 3.14159265 / 180

        ; Calculate button position
        btnX := centerX + (Cos(angleRad) * radius) - (buttonWidth // 2)
        btnY := centerY + (Sin(angleRad) * radius) - (buttonHeight // 2)

        ; Create button
        btn := WheelMenuGui.Add("Button", "x" . btnX . " y" . btnY . " w" . buttonWidth . " h" . buttonHeight, action.name . "`n[" . action.key . "]")
        btn.OnEvent("Click", (*) => SelectWheelAction(action.id))

        ; Store button reference
        WheelMenuButtons[action.id] := btn
    }

    ; Add center circle label
    centerText := WheelMenuGui.Add("Text", "x" . (centerX - centerSize//2) . " y" . (centerY - 30) . " w" . centerSize . " h60 Center BackgroundTrans", "WHEEL MENU`n`nMove mouse`nor press 1-6")
    WheelMenuGui.SetFont("s10 Norm cWhite", "Segoe UI")

    ; Position GUI centered on mouse
    guiX := WheelMenuStartX - menuSize // 2
    guiY := WheelMenuStartY - menuSize // 2

    ; Set transparency
    WinSetTransColor "1a1a1a 230", WheelMenuGui

    ; Show GUI
    WheelMenuGui.Show("x" . guiX . " y" . guiY . " w" . menuSize . " h" . menuSize . " NoActivate")

    ; Mark menu as active
    WheelMenuActive := true
    WheelMenuSelectedAction := 0

    ; Start mouse tracking timer
    WheelMenuTimer := SetTimer(UpdateWheelSelection, 50)
}

SelectWheelAction(actionId) {
    global WheelMenuActive, WheelMenuActions

    if (!WheelMenuActive) {
        return
    }

    ; Find the selected action
    selectedHandler := ""
    for action in WheelMenuActions {
        if (action.id = actionId) {
            selectedHandler := action.handler
            break
        }
    }

    ; Close menu first
    CloseWheelMenu()

    ; Execute the handler
    if (selectedHandler != "" && selectedHandler != "Cancel") {
        ; Small delay to ensure menu is closed
        Sleep 100
        %selectedHandler%()
    }
}

CloseWheelMenu() {
    global WheelMenuActive, WheelMenuGui, WheelMenuTimer

    if (!WheelMenuActive) {
        return
    }

    ; Stop timer
    if (WheelMenuTimer) {
        SetTimer WheelMenuTimer, 0
        WheelMenuTimer := ""
    }

    ; Mark as inactive first
    WheelMenuActive := false

    ; Destroy GUI
    try {
        WheelMenuGui.Destroy()
    }
}

UpdateWheelSelection() {
    global WheelMenuActive, WheelMenuButtons, WheelMenuStartX, WheelMenuStartY

    if (!WheelMenuActive) {
        return
    }

    ; Get current mouse position
    MouseGetPos &currentX, &currentY

    ; Calculate distance from center
    deltaX := currentX - WheelMenuStartX
    deltaY := currentY - WheelMenuStartY
    distance := Sqrt(deltaX * deltaX + deltaY * deltaY)

    ; Highlight button based on mouse angle (visual feedback only)
    ; The actual button hovers work natively
    ; This function can be expanded later for custom hover effects
}

; Conditional hotkeys - only active when menu is open
#HotIf WheelMenuActive
1::SelectWheelAction(1)
2::SelectWheelAction(2)
3::SelectWheelAction(3)
4::SelectWheelAction(4)
5::SelectWheelAction(5)
6::SelectWheelAction(6)
Escape::CloseWheelMenu()
#HotIf

; Helper function for atan2
ATan2(y, x) {
    if (x > 0) {
        return ATan(y / x)
    } else if (x < 0) {
        if (y >= 0) {
            return ATan(y / x) + 3.14159265
        } else {
            return ATan(y / x) - 3.14159265
        }
    } else {
        if (y > 0) {
            return 3.14159265 / 2
        } else if (y < 0) {
            return -3.14159265 / 2
        } else {
            return 0
        }
    }
}

; ============================================================================
; Exit Hotkey: Ctrl+Alt+Q to quit script
; ============================================================================

^!q:: {
    result := MsgBox("Are you sure you want to exit?", "Exit Solscan Hotkey", "YesNo")
    if (result = "Yes") {
        ExitApp
    }
}

; ============================================================================
; Tray Menu Customization
; ============================================================================

A_TrayMenu.Delete()
A_TrayMenu.Add("Reload Script", (*) => Reload())
A_TrayMenu.Add("Exit", (*) => ExitApp())
A_IconTip := "Solscan Hotkey Active`nF13: Wheel Menu (all actions)`nF14: Open address`nF15: Defined.fi lookup`nF16: Analyze token`nCtrl+F14: Monitor address"