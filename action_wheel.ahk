; ============================================================================
; Gun Del Sol - Solana Analysis Toolkit
; ============================================================================
; Description: Mouse-driven Solana address and token analysis toolkit
; Author: Generated by Claude Code
; Version: 3.0 (AutoHotkey v2) - Wheel Menu Edition
;
; Recent changes:
; - Configurable wheel menu hotkey (defaults to backtick `)
; - Mouse gesture or keyboard (1-6) selection
; - Visual feedback with real-time hover states
; - Settings dialog for customizing hotkeys and actions
; ============================================================================

#Requires AutoHotkey v2.0
#SingleInstance Force
SetWorkingDir A_ScriptDir
SendMode "Input"
CoordMode "Mouse", "Screen"

; ============================================================================
; GDI+ helper functions for wheel menu rendering
; ============================================================================
; IMPORTANT: These must be defined BEFORE InitGdip() is called below

Gdip_Startup() {
    static loaded := false
    static loadedToken := 0

    ; If already initialized, return existing token
    if (loaded && loadedToken) {
        return loadedToken
    }

    ; Load GDI+ library
    if (!loaded) {
        DllCall("LoadLibrary", "str", "gdiplus.dll", "Ptr")
        loaded := true
    }

    ; Initialize GDI+
    si := Buffer(24, 0)  ; Increased size for 64-bit compatibility
    NumPut("UInt", 1, si, 0)                    ; GdiplusVersion

    token := 0
    status := DllCall("gdiplus\GdiplusStartup", "Ptr*", &token, "Ptr", si, "Ptr", 0, "UInt")

    if (status != 0 || token == 0) {
        MsgBox("GDI+ initialization failed!`nStatus: " . status . "`nToken: " . token . "`n`nTry reloading the script (Ctrl+R)")
        return 0
    }

    loadedToken := token
    return token
}

Gdip_Shutdown(token) {
    if (token)
        DllCall("gdiplus\GdiplusShutdown", "Ptr", token)
}

Gdip_GraphicsFromHDC(hdc) {
    graphics := 0
    if (DllCall("gdiplus\GdipCreateFromHDC", "Ptr", hdc, "Ptr*", &graphics, "UInt"))
        return 0
    return graphics
}

Gdip_DeleteGraphics(graphics) {
    if (graphics)
        DllCall("gdiplus\GdipDeleteGraphics", "Ptr", graphics)
}

Gdip_SetSmoothingMode(graphics, mode) {
    return DllCall("gdiplus\GdipSetSmoothingMode", "Ptr", graphics, "Int", mode, "UInt")
}

Gdip_SetCompositingMode(graphics, mode) {
    return DllCall("gdiplus\GdipSetCompositingMode", "Ptr", graphics, "Int", mode, "UInt")
}

Gdip_GraphicsClear(graphics, argb) {
    return DllCall("gdiplus\GdipGraphicsClear", "Ptr", graphics, "UInt", argb, "UInt")
}

Gdip_CreatePen(argb, width) {
    pen := 0
    DllCall("gdiplus\GdipCreatePen1", "UInt", argb, "Float", width, "Int", 2, "Ptr*", &pen, "UInt")
    return pen
}

Gdip_DeletePen(pen) {
    if (pen)
        DllCall("gdiplus\GdipDeletePen", "Ptr", pen)
}

Gdip_DrawPath(graphics, pen, path) {
    return DllCall("gdiplus\GdipDrawPath", "Ptr", graphics, "Ptr", pen, "Ptr", path, "UInt")
}

Gdip_BrushCreateSolid(argb) {
    brush := 0
    if (DllCall("gdiplus\GdipCreateSolidFill", "UInt", argb, "Ptr*", &brush, "UInt"))
        return 0
    return brush
}

Gdip_DeleteBrush(brush) {
    if (brush)
        DllCall("gdiplus\GdipDeleteBrush", "Ptr", brush)
}

Gdip_FillPie(graphics, brush, x, y, w, h, startAngle, sweepAngle) {
    return DllCall("gdiplus\GdipFillPie", "Ptr", graphics, "Ptr", brush
        , "Float", x, "Float", y, "Float", w, "Float", h
        , "Float", startAngle, "Float", sweepAngle, "UInt")
}

Gdip_FillEllipse(graphics, brush, x, y, w, h) {
    return DllCall("gdiplus\GdipFillEllipse", "Ptr", graphics, "Ptr", brush
        , "Float", x, "Float", y, "Float", w, "Float", h, "UInt")
}

Gdip_FillRectangle(graphics, brush, x, y, w, h) {
    return DllCall("gdiplus\GdipFillRectangle", "Ptr", graphics, "Ptr", brush
        , "Float", x, "Float", y, "Float", w, "Float", h, "UInt")
}

Gdip_CreatePath() {
    path := 0
    DllCall("gdiplus\GdipCreatePath", "Int", 0, "Ptr*", &path, "UInt")
    return path
}

Gdip_DeletePath(path) {
    if (path)
        DllCall("gdiplus\GdipDeletePath", "Ptr", path)
}

Gdip_AddPathRoundedRectangle(path, x, y, w, h, radius) {
    ; Create a rounded rectangle path
    DllCall("gdiplus\GdipAddPathArc", "Ptr", path, "Float", x, "Float", y, "Float", radius*2, "Float", radius*2, "Float", 180, "Float", 90, "UInt")
    DllCall("gdiplus\GdipAddPathArc", "Ptr", path, "Float", x+w-radius*2, "Float", y, "Float", radius*2, "Float", radius*2, "Float", 270, "Float", 90, "UInt")
    DllCall("gdiplus\GdipAddPathArc", "Ptr", path, "Float", x+w-radius*2, "Float", y+h-radius*2, "Float", radius*2, "Float", radius*2, "Float", 0, "Float", 90, "UInt")
    DllCall("gdiplus\GdipAddPathArc", "Ptr", path, "Float", x, "Float", y+h-radius*2, "Float", radius*2, "Float", radius*2, "Float", 90, "Float", 90, "UInt")
    DllCall("gdiplus\GdipClosePathFigure", "Ptr", path, "UInt")
}

Gdip_FillPath(graphics, brush, path) {
    return DllCall("gdiplus\GdipFillPath", "Ptr", graphics, "Ptr", brush, "Ptr", path, "UInt")
}

Gdip_CreateFont(fontFamily, fontSize, fontStyle) {
    font := 0
    if (DllCall("gdiplus\GdipCreateFont", "Ptr", fontFamily, "Float", fontSize, "Int", fontStyle, "Int", 2, "Ptr*", &font, "UInt"))
        return 0
    return font
}

Gdip_CreateFontFamily(name) {
    fontFamily := 0
    if (DllCall("gdiplus\GdipCreateFontFamilyFromName", "WStr", name, "Ptr", 0, "Ptr*", &fontFamily, "UInt"))
        return 0
    return fontFamily
}

Gdip_DeleteFont(font) {
    if (font)
        DllCall("gdiplus\GdipDeleteFont", "Ptr", font)
}

Gdip_DeleteFontFamily(fontFamily) {
    if (fontFamily)
        DllCall("gdiplus\GdipDeleteFontFamily", "Ptr", fontFamily)
}

Gdip_CreateStringFormat(formatFlags, language) {
    format := 0
    if (DllCall("gdiplus\GdipCreateStringFormat", "Int", formatFlags, "UShort", language, "Ptr*", &format, "UInt"))
        return 0
    return format
}

Gdip_DeleteStringFormat(format) {
    if (format)
        DllCall("gdiplus\GdipDeleteStringFormat", "Ptr", format)
}

Gdip_SetStringFormatAlign(format, align) {
    return DllCall("gdiplus\GdipSetStringFormatAlign", "Ptr", format, "Int", align, "UInt")
}

Gdip_SetStringFormatLineAlign(format, align) {
    return DllCall("gdiplus\GdipSetStringFormatLineAlign", "Ptr", format, "Int", align, "UInt")
}

Gdip_DrawString(graphics, text, font, brush, x, y, w, h, format) {
    rectF := Buffer(16, 0)
    NumPut("Float", x, rectF, 0)
    NumPut("Float", y, rectF, 4)
    NumPut("Float", w, rectF, 8)
    NumPut("Float", h, rectF, 12)
    return DllCall("gdiplus\GdipDrawString", "Ptr", graphics, "WStr", text, "Int", -1
        , "Ptr", font, "Ptr", rectF, "Ptr", format, "Ptr", brush, "UInt")
}

CreateDIBSection(width, height) {
    hdc := DllCall("user32\GetDC", "Ptr", 0, "Ptr")
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)                   ; biSize
    NumPut("Int", width, bi, 4)                 ; biWidth
    NumPut("Int", -height, bi, 8)               ; biHeight (top-down)
    NumPut("UShort", 1, bi, 12)                 ; biPlanes
    NumPut("UShort", 32, bi, 14)                ; biBitCount
    NumPut("UInt", 0, bi, 16)                   ; biCompression (BI_RGB)
    pvBits := 0
    hbm := DllCall("gdi32\CreateDIBSection", "Ptr", hdc, "Ptr", bi, "UInt", 0
        , "Ptr*", &pvBits, "Ptr", 0, "UInt", 0, "Ptr")
    DllCall("user32\ReleaseDC", "Ptr", 0, "Ptr", hdc)
    return hbm
}

CreateCompatibleDC() {
    return DllCall("gdi32\CreateCompatibleDC", "Ptr", 0, "Ptr")
}

SelectObject(hdc, object) {
    return DllCall("gdi32\SelectObject", "Ptr", hdc, "Ptr", object, "Ptr")
}

DeleteDC(hdc) {
    if (hdc)
        DllCall("gdi32\DeleteDC", "Ptr", hdc)
}

DeleteObject(hObj) {
    if (hObj)
        DllCall("gdi32\DeleteObject", "Ptr", hObj)
}

UpdateLayeredWindow(hwnd, hdc, x, y, width, height) {
    size := Buffer(8, 0)
    NumPut("Int", width, size, 0)
    NumPut("Int", height, size, 4)

    ptSrc := Buffer(8, 0)
    ptDest := Buffer(8, 0)
    NumPut("Int", x, ptDest, 0)
    NumPut("Int", y, ptDest, 4)

    blend := Buffer(4, 0)
    NumPut("UChar", 0, blend, 0)                ; AC_SRC_OVER
    NumPut("UChar", 0, blend, 1)                ; BlendFlags
    NumPut("UChar", 255, blend, 2)              ; SourceConstantAlpha
    NumPut("UChar", 1, blend, 3)                ; AC_SRC_ALPHA

    return DllCall("user32\UpdateLayeredWindow", "Ptr", hwnd, "Ptr", 0
        , "Ptr", ptDest, "Ptr", size, "Ptr", hdc, "Ptr", ptSrc
        , "UInt", 0, "Ptr", blend, "UInt", 0x02)
}

; Configuration
NOTIFICATION_DURATION := 2000  ; milliseconds
SELECTION_DELAY := 100         ; delay after selection before copy
LOCAL_SERVER_URL := "http://localhost:5001/register"  ; Telegram monitor service

; GDI+ initialization
global g_GdipToken := 0

InitGdip() {
    global g_GdipToken
    if !g_GdipToken {
        g_GdipToken := Gdip_Startup()
        if (!g_GdipToken) {
            MsgBox "GDI+ failed to initialize! Token: " . g_GdipToken
            ExitApp
        }
        OnExit(ShutdownGdip)
    }
}

ShutdownGdip(*) {
    global g_GdipToken
    if g_GdipToken {
        Gdip_Shutdown(g_GdipToken)
        g_GdipToken := 0
    }
}

; Initialize GDI+ on startup
InitGdip()

; ============================================================================
; Settings Management
; ============================================================================

global WheelMenuHotkey := "``"  ; Current hotkey for wheel menu (backtick by default)
global WheelMenuActions := [
    "Solscan",      ; Wedge 1 (Top)
    "Exclude",      ; Wedge 2 (Top-Right)
    "Monitor",      ; Wedge 3 (Bottom-Right)
    "Defined.fi",   ; Wedge 4 (Bottom)
    "Analyze",      ; Wedge 5 (Bottom-Left)
    "Cancel"        ; Wedge 6 (Top-Left)
]

LoadSettings() {
    global WheelMenuHotkey, WheelMenuActions

    settingsFile := A_ScriptDir . "\action_wheel_settings.ini"

    ; Load hotkey (default: backtick)
    WheelMenuHotkey := IniRead(settingsFile, "Hotkeys", "WheelMenu", "``")

    ; Load wedge actions
    defaultActions := ["Solscan", "Exclude", "Monitor", "Defined.fi", "Analyze", "Cancel"]
    Loop 6 {
        WheelMenuActions[A_Index] := IniRead(settingsFile, "Actions", "Wedge" . A_Index, defaultActions[A_Index])
    }
}

SaveSettings() {
    global WheelMenuHotkey, WheelMenuActions

    settingsFile := A_ScriptDir . "\action_wheel_settings.ini"

    ; Save hotkey
    IniWrite(WheelMenuHotkey, settingsFile, "Hotkeys", "WheelMenu")

    ; Save wedge actions
    Loop 6 {
        IniWrite(WheelMenuActions[A_Index], settingsFile, "Actions", "Wedge" . A_Index)
    }
}

; Helper function to convert AutoHotkey syntax to readable format
HotkeyToReadable(hotkeyStr) {
    if (hotkeyStr == "")
        return ""

    readable := ""

    ; Process each character and convert modifiers
    i := 1
    while (i <= StrLen(hotkeyStr)) {
        char := SubStr(hotkeyStr, i, 1)

        switch char {
            case "^":
                readable .= "Ctrl+"
            case "!":
                readable .= "Alt+"
            case "+":
                readable .= "Shift+"
            case "#":
                readable .= "Win+"
            default:
                ; This is the actual key, append the rest of the string
                readable .= SubStr(hotkeyStr, i)
                break
        }
        i++
    }

    ; Capitalize the key at the end
    readable := StrUpper(readable)

    return readable
}

; Helper function to convert readable format back to AutoHotkey syntax
ReadableToHotkey(readableStr) {
    if (readableStr == "")
        return ""

    hotkey := readableStr

    ; Replace readable names with modifier symbols (case-insensitive)
    hotkey := RegExReplace(hotkey, "i)Ctrl\+", "^")
    hotkey := RegExReplace(hotkey, "i)Alt\+", "!")
    hotkey := RegExReplace(hotkey, "i)Shift\+", "+")
    hotkey := RegExReplace(hotkey, "i)Win\+", "#")

    return hotkey
}

ShowSettingsWindow(*) {
    global WheelMenuHotkey, WheelMenuActions

    settingsGui := Gui("+AlwaysOnTop", "Solscan Hotkey Settings")

    ; Hotkey selection section
    settingsGui.Add("GroupBox", "x10 y10 w380 h100", "Wheel Menu Hotkey")
    settingsGui.Add("Text", "x20 y35", "Press any key or mouse button:")
    ; Display the hotkey in readable format
    readableHotkey := HotkeyToReadable(WheelMenuHotkey)
    hotkeyEdit := settingsGui.Add("Edit", "x20 y55 w200 vHotkeyInput ReadOnly", readableHotkey)
    settingsGui.Add("Button", "x230 y55 w80", "Record Key").OnEvent("Click", RecordHotkey.Bind(settingsGui, hotkeyEdit))
    settingsGui.Add("Text", "x20 y85 cGray", "Examples: F13-F24, XButton1, Ctrl+Alt+F1")

    ; Pie wedge actions section
    settingsGui.Add("GroupBox", "x10 y120 w380 h225", "Pie Wedge Actions")

    actionList := ["Solscan", "Exclude", "Monitor", "Defined.fi", "Analyze", "Cancel"]
    wedgeNames := ["Top", "Top-Right", "Bottom-Right", "Bottom", "Bottom-Left", "Top-Left"]

    Loop 6 {
        y := 140 + (A_Index - 1) * 35
        settingsGui.Add("Text", "x20 y" . y, "Wedge " . A_Index . " (" . wedgeNames[A_Index] . "):")
        dropdown := settingsGui.Add("DropDownList", "x200 y" . (y-3) . " w170 vAction" . A_Index, actionList)

        ; Select current action - find index in actionList
        currentAction := WheelMenuActions[A_Index]
        for index, action in actionList {
            if (action == currentAction) {
                dropdown.Value := index
                break
            }
        }
    }

    ; Buttons
    settingsGui.Add("Button", "x10 y355 w120", "Save").OnEvent("Click", SaveSettingsFromGui.Bind(settingsGui))
    settingsGui.Add("Button", "x140 y355 w120", "Cancel").OnEvent("Click", (*) => settingsGui.Destroy())

    settingsGui.Show("w400 h395")
}

RecordHotkey(guiObj, editControl, *) {
    static hookActive := false
    static currentIh := ""
    static currentRecordGui := ""
    static currentStatusText := ""
    static currentGuiObj := ""
    static currentEditControl := ""
    static mouseButtons := ["XButton1", "XButton2", "MButton"]
    static escapePressed := false

    ; Force cleanup if stuck in active state
    if (hookActive) {
        ; Try to force cleanup - disable all possible hotkeys
        try {
            Hotkey "Escape", "Off"
            for btn in mouseButtons {
                try Hotkey btn, "Off"
                try Hotkey "^" . btn, "Off"
                try Hotkey "!" . btn, "Off"
                try Hotkey "+" . btn, "Off"
                try Hotkey "#" . btn, "Off"
            }
            Loop 26 {
                letter := Chr(96 + A_Index)
                try Hotkey "~" . letter, "Off"
                try Hotkey "~^" . letter, "Off"
                try Hotkey "~!" . letter, "Off"
                try Hotkey "~+" . letter, "Off"
            }
            Loop 24 {
                fkey := "F" . A_Index
                try Hotkey "~" . fkey, "Off"
                try Hotkey "~^" . fkey, "Off"
            }
            if (currentRecordGui)
                currentRecordGui.Destroy()
        }
        hookActive := false
        ; Now allow the new session to start
    }

    ; Store references for callbacks
    currentGuiObj := guiObj
    currentEditControl := editControl
    hookActive := true
    escapePressed := false

    ; Disable the wheel menu hotkey while recording to prevent interference
    global WheelMenuHotkey
    try {
        Hotkey WheelMenuHotkey, "Off"
        Hotkey WheelMenuHotkey . " Up", "Off"
    }

    ; Create a modal dialog for recording the hotkey
    recordGui := Gui("+AlwaysOnTop +ToolWindow", "Record Hotkey")
    recordGui.Add("Text", "x20 y20 w260", "Press any key or mouse button...`n`nPress ESC to cancel")
    statusText := recordGui.Add("Text", "x20 y60 w260 vRecordedKey", "Waiting...")
    currentRecordGui := recordGui
    currentStatusText := statusText

    recordGui.Show("w300 h100")

    ; Use hotkey-based capture for reliable combination detection
    ; Register a hotkey for every possible key
    currentIh := ""  ; Not using InputHook anymore

    ; ESC to cancel (must be first)
    try {
        Hotkey "Escape", CancelHotkeyRecording, "On"
    }

    ; Also capture mouse buttons
    for btn in mouseButtons {
        try {
            Hotkey btn, CaptureAnyKey, "On"
            Hotkey "^" . btn, CaptureAnyKey, "On"
            Hotkey "!" . btn, CaptureAnyKey, "On"
            Hotkey "+" . btn, CaptureAnyKey, "On"
            Hotkey "#" . btn, CaptureAnyKey, "On"
        }
    }

    ; Register hotkeys for all common keys with all modifier combinations
    ; Letters a-z
    try {
        Loop 26 {
            letter := Chr(96 + A_Index)  ; a-z
            Hotkey "~" . letter, CaptureAnyKey, "On"
            Hotkey "~^" . letter, CaptureAnyKey, "On"      ; Ctrl
            Hotkey "~!" . letter, CaptureAnyKey, "On"      ; Alt
            Hotkey "~+" . letter, CaptureAnyKey, "On"      ; Shift
            Hotkey "~#" . letter, CaptureAnyKey, "On"      ; Win
            Hotkey "~^!" . letter, CaptureAnyKey, "On"     ; Ctrl+Alt
            Hotkey "~^+" . letter, CaptureAnyKey, "On"     ; Ctrl+Shift
            Hotkey "~!+" . letter, CaptureAnyKey, "On"     ; Alt+Shift
            Hotkey "~^!+" . letter, CaptureAnyKey, "On"    ; Ctrl+Alt+Shift
        }
    }

    ; Function keys F1-F24
    try {
        Loop 24 {
            fkey := "F" . A_Index
            Hotkey "~" . fkey, CaptureAnyKey, "On"
            Hotkey "~^" . fkey, CaptureAnyKey, "On"
            Hotkey "~!" . fkey, CaptureAnyKey, "On"
            Hotkey "~+" . fkey, CaptureAnyKey, "On"
            Hotkey "~#" . fkey, CaptureAnyKey, "On"
            Hotkey "~^!" . fkey, CaptureAnyKey, "On"
            Hotkey "~^+" . fkey, CaptureAnyKey, "On"
            Hotkey "~!+" . fkey, CaptureAnyKey, "On"
            Hotkey "~^!+" . fkey, CaptureAnyKey, "On"
        }
    }

    ; Number keys 0-9
    try {
        Loop 10 {
            num := A_Index - 1
            Hotkey "~" . num, CaptureAnyKey, "On"
            Hotkey "~^" . num, CaptureAnyKey, "On"
            Hotkey "~!" . num, CaptureAnyKey, "On"
            Hotkey "~+" . num, CaptureAnyKey, "On"
            Hotkey "~#" . num, CaptureAnyKey, "On"
        }
    }

    ; Special keys
    try {
        specialKeys := ["Space", "Tab", "Enter", "BackSpace", "Delete", "Insert",
                        "Home", "End", "PgUp", "PgDn", "Up", "Down", "Left", "Right", "``"]
        for key in specialKeys {
            Hotkey "~" . key, CaptureAnyKey, "On"
            Hotkey "~^" . key, CaptureAnyKey, "On"
            Hotkey "~!" . key, CaptureAnyKey, "On"
            Hotkey "~+" . key, CaptureAnyKey, "On"
            Hotkey "~#" . key, CaptureAnyKey, "On"
        }
    }

    ; Capture function
    CaptureAnyKey(hotkeyName) {
        if (!hookActive || escapePressed)
            return

        ; The hotkeyName comes in with the ~ prefix, like "~^+t" for Ctrl+Shift+T
        ; We need to remove only the leading ~ to get "^+t"
        capturedKey := hotkeyName
        if (SubStr(capturedKey, 1, 1) == "~") {
            capturedKey := SubStr(capturedKey, 2)  ; Remove first character (~)
        }

        ; Convert to readable format for display
        readableKey := HotkeyToReadable(capturedKey)
        currentStatusText.Text := "Captured: " . readableKey

        ; Pass the readable version to cleanup (will be displayed in textbox)
        CleanupAndFinish(readableKey)
    }

    ; Cancel recording
    CancelHotkeyRecording(*) {
        if (!hookActive)
            return

        escapePressed := true
        CleanupAndFinish("")
    }

    ; Cleanup and finish
    CleanupAndFinish(capturedKey) {
        ; Ensure hookActive is always set to false
        hookActive := false

        ; Disable ESC hotkey
        try {
            Hotkey "Escape", "Off"
        }

        ; Disable mouse button hotkeys
        try {
            for btn in mouseButtons {
                try Hotkey btn, "Off"
                try Hotkey "^" . btn, "Off"
                try Hotkey "!" . btn, "Off"
                try Hotkey "+" . btn, "Off"
                try Hotkey "#" . btn, "Off"
            }
        }

        ; Disable all letter hotkeys with all combinations
        try {
            Loop 26 {
                letter := Chr(96 + A_Index)
                try Hotkey "~" . letter, "Off"
                try Hotkey "~^" . letter, "Off"
                try Hotkey "~!" . letter, "Off"
                try Hotkey "~+" . letter, "Off"
                try Hotkey "~#" . letter, "Off"
                try Hotkey "~^!" . letter, "Off"
                try Hotkey "~^+" . letter, "Off"
                try Hotkey "~!+" . letter, "Off"
                try Hotkey "~^!+" . letter, "Off"
            }
        }

        ; Disable function keys
        try {
            Loop 24 {
                fkey := "F" . A_Index
                try Hotkey "~" . fkey, "Off"
                try Hotkey "~^" . fkey, "Off"
                try Hotkey "~!" . fkey, "Off"
                try Hotkey "~+" . fkey, "Off"
                try Hotkey "~#" . fkey, "Off"
                try Hotkey "~^!" . fkey, "Off"
                try Hotkey "~^+" . fkey, "Off"
                try Hotkey "~!+" . fkey, "Off"
                try Hotkey "~^!+" . fkey, "Off"
            }
        }

        ; Disable number keys
        try {
            Loop 10 {
                num := A_Index - 1
                try Hotkey "~" . num, "Off"
                try Hotkey "~^" . num, "Off"
                try Hotkey "~!" . num, "Off"
                try Hotkey "~+" . num, "Off"
                try Hotkey "~#" . num, "Off"
            }
        }

        ; Disable special keys
        try {
            specialKeys := ["Space", "Tab", "Enter", "BackSpace", "Delete", "Insert",
                            "Home", "End", "PgUp", "PgDn", "Up", "Down", "Left", "Right", "``"]
            for key in specialKeys {
                try Hotkey "~" . key, "Off"
                try Hotkey "~^" . key, "Off"
                try Hotkey "~!" . key, "Off"
                try Hotkey "~+" . key, "Off"
                try Hotkey "~#" . key, "Off"
            }
        }

        ; Re-enable the wheel menu hotkey
        try {
            Hotkey WheelMenuHotkey, "On"
            Hotkey WheelMenuHotkey . " Up", "On"
        }

        ; Update the edit control if we captured a key
        try {
            if (capturedKey != "" && currentEditControl) {
                currentEditControl.Value := capturedKey
            }
        }

        ; Close recording dialog
        try {
            if (currentRecordGui)
                currentRecordGui.Destroy()
        }

        ; Clear static references
        currentIh := ""
        currentRecordGui := ""
        currentStatusText := ""
        currentGuiObj := ""
        currentEditControl := ""
        escapePressed := false
    }
}

SaveSettingsFromGui(guiObj, *) {
    global WheelMenuHotkey, WheelMenuActions

    ; Get submitted values
    submitted := guiObj.Submit(false)

    ; Get hotkey from text field (it's in readable format like "Ctrl+Shift+F")
    readableHotkey := submitted.HotkeyInput

    ; Validate hotkey is not empty
    if (readableHotkey == "") {
        MsgBox("Please record a hotkey before saving!", "Invalid Hotkey", "OK Iconx")
        return
    }

    ; Convert readable format back to AutoHotkey syntax
    WheelMenuHotkey := ReadableToHotkey(readableHotkey)

    ; Get wedge actions - need to access controls directly to get numeric index
    actionList := ["Solscan", "Exclude", "Monitor", "Defined.fi", "Analyze", "Cancel"]
    Loop 6 {
        ; Get the control by name and read its Value property (which is the numeric index)
        controlName := "Action" . A_Index
        control := guiObj[controlName]
        actionIndex := control.Value  ; This returns the numeric index (1-6)
        WheelMenuActions[A_Index] := actionList[actionIndex]
    }

    ; Save to INI file
    SaveSettings()

    ; Close settings window
    guiObj.Destroy()

    ; Show confirmation and reload
    MsgBox("Settings saved!`n`nThe script will now reload to apply the new hotkey.", "Settings Saved", "OK")
    Reload()
}

; Load settings on startup
LoadSettings()

; Global variables for action handlers
global currentMainAddress := ""
global excludedAddressesList := []

; Wheel menu captured address (stores address at menu open time)
global WheelMenuCapturedAddress := ""
global WheelMenuHotkeyPressed := false  ; Track hotkey state to prevent repeat triggers

; ============================================================================
; DYNAMIC HOTKEY: Configurable via Settings
; ============================================================================
; Opens radial wheel menu with Blender-style press-and-hold interaction
;
; INTERACTION:
; - Press and HOLD hotkey → Menu opens, move mouse to desired action
; - Release hotkey → Activates the action your mouse is pointing toward
; - OR press number key (1-6) while holding to select action directly
;
; To change the hotkey, right-click tray icon → Settings
; ============================================================================

; Register the configured hotkey dynamically
Hotkey WheelMenuHotkey, HandleWheelMenuPress
Hotkey WheelMenuHotkey . " Up", HandleWheelMenuRelease

HandleWheelMenuPress(*) {
    global WheelMenuHotkeyPressed
    ; Only open menu on first press, ignore repeat triggers while held
    if (!WheelMenuHotkeyPressed) {
        WheelMenuHotkeyPressed := true
        ShowWheelMenu()
    }
}

HandleWheelMenuRelease(*) {
    global WheelMenuActive, WheelMenuLastHovered, WheelMenuHotkeyPressed

    ; Reset key state
    WheelMenuHotkeyPressed := false

    ; Only handle release if menu is active
    if (!WheelMenuActive) {
        return
    }

    ; Execute action for currently hovered slice
    if (WheelMenuLastHovered > 0) {
        SelectWheelAction(WheelMenuLastHovered)
    } else {
        ; Mouse is in center dead zone - just close menu (cancel)
        CloseWheelMenu()
    }
}

; ============================================================================
; Core Function: Capture text and open Solscan
; ============================================================================

HandleSolscanLookup() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Store this as the current main address and reset exclusions
            global currentMainAddress := address
            global excludedAddressesList := []

            OpenSolscan(address)
            ShowNotification("Opening Solscan...", address)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Core Function: Capture text and open Solscan WITH EXCLUDE FILTER
; ============================================================================

HandleSolscanLookupWithExclude() {
    ; IMPORTANT: Capture text FIRST before doing any navigation
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; NOW get the current URL and parse both address and existing exclusions
    urlData := GetAddressAndExclusionsFromURL()
    currentAddress := urlData.address
    existingExclusions := urlData.exclusions

    ; Validate we're on a Solscan page
    if (currentAddress == "") {
        ShowNotification("No Solscan page detected", "Open a Solscan address page first")
        return
    }

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text (handles URLs and mixed content)
        addressToExclude := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (addressToExclude == "" && IsValidSolanaAddress(capturedText)) {
            addressToExclude := capturedText
        }

        ; Validate the address to exclude
        if (addressToExclude != "" && IsValidSolanaAddress(addressToExclude)) {
            ; Check if already excluded
            alreadyExcluded := false
            for index, addr in existingExclusions {
                if (addr == addressToExclude) {
                    alreadyExcluded := true
                    break
                }
            }

            if (!alreadyExcluded) {
                existingExclusions.Push(addressToExclude)
            }

            ; Reload the current page with updated exclusions
            ReloadPageWithExclusions(currentAddress, existingExclusions)
            ShowNotification("Excluded address added", addressToExclude)
        } else {
            ShowNotification("Not a valid Solana address", capturedText)
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

; ============================================================================
; Text Capture Logic
; ============================================================================

CaptureTextUnderCursor() {
    ; Strategy 1: Check if text is already selected
    Send "^c"
    if ClipWait(0.15) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; Strategy 2: Double-click to select word under cursor
    Click
    Sleep 20
    Click
    Sleep 50

    ; Copy selected text
    Send "^c"
    if ClipWait(0.2) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            captured := Trim(A_Clipboard)
            return captured
        }
    }

    ; Strategy 3: Select entire line (fallback)
    Send "{Home}"
    Send "+{End}"
    Sleep 50
    Send "^c"
    if ClipWait(0.2) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return A_Clipboard
        }
    }

    return ""
}

; ============================================================================
; Text Capture for Exclusion (Selection-Based Only)
; ============================================================================
; This function ONLY captures pre-selected text to avoid any mouse clicks
; User must manually select/highlight the address before pressing XButton1

CaptureTextWithoutClicking() {
    ; Only try to copy already-selected text
    ; No mouse clicking or automatic selection
    A_Clipboard := ""
    Send "^c"

    if ClipWait(0.3) {
        if (A_Clipboard != "" && StrLen(A_Clipboard) > 0) {
            return Trim(A_Clipboard)
        }
    }

    ; If nothing was selected, return empty
    ; User needs to manually select the address first
    return ""
}

; ============================================================================
; Validation: Solana Address Pattern
; ============================================================================

IsValidSolanaAddress(text) {
    ; Remove whitespace and quotes
    text := Trim(text)
    text := StrReplace(text, "`r", "")
    text := StrReplace(text, "`n", "")
    text := StrReplace(text, " ", "")
    text := StrReplace(text, '"', "")
    text := StrReplace(text, "'", "")

    ; Solana addresses are base58 encoded, 32-44 characters
    length := StrLen(text)
    if (length < 32 || length > 44) {
        return false
    }

    ; Check if all characters are valid base58 (excludes 0, O, I, l)
    Loop Parse, text
    {
        char := A_LoopField
        ; Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
        if !RegExMatch(char, "[1-9A-HJ-NP-Za-km-z]") {
            return false
        }
    }

    return true
}

; ============================================================================
; Helper: Extract address from longer text
; ============================================================================

ExtractAddressFromText(text) {
    ; Try to find a base58 string of correct length
    if RegExMatch(text, "[1-9A-HJ-NP-Za-km-z]{32,44}", &match) {
        return match[0]
    }
    return ""
}

; ============================================================================
; Helper: Get address and exclusions from current browser URL (Combined)
; ============================================================================
; IMPORTANT: This function depends on Solscan's URL structure
;
; URL Structure Dependencies (as of 2025):
; -----------------------------------------
; 1. Main address format:
;    https://solscan.io/account/{ADDRESS}?params...
;    Regex: "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})"
;
; 2. Exclusion parameter format:
;    &to_address=!Addr1,!Addr2,!Addr3
;    - Parameter name: "to_address"
;    - Exclusion prefix: "!" (exclamation mark)
;    - Separator: "," (comma)
;    - URL encoded: %21 for !, %2C for comma (case insensitive)
;    Regex: "to_address=([^&]+)"
;
; If Solscan changes their URL structure, update the following:
; - Line ~306: Main address regex pattern
; - Line ~312: Exclusion parameter name
; - Line ~316: Exclusion prefix character
; - Line ~319: Separator character
;
; Fallback behavior if parsing fails:
; - result.address will be "" (empty string)
; - result.exclusions will be [] (empty array)
; - Script will show "No Solscan page detected" notification
; ============================================================================

GetAddressAndExclusionsFromURL() {
    ; Get the current browser URL by copying it from the address bar
    ; Save clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Select address bar (Ctrl+L works in most browsers)
    Send "^l"
    Sleep 100

    ; Copy URL
    Send "^c"
    Sleep 100

    ; Get URL from clipboard
    currentURL := A_Clipboard

    ; Restore clipboard
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Press Escape to deselect address bar
    Send "{Escape}"

    ; Create result object
    result := {address: "", exclusions: []}

    ; Extract address from Solscan URL
    ; Format: https://solscan.io/account/ADDRESS...
    ; UPDATE THIS if Solscan changes their URL pattern
    if RegExMatch(currentURL, "solscan\.io/account/([1-9A-HJ-NP-Za-km-z]{32,44})", &match) {
        result.address := match[1]
    }

    ; Parse existing exclusions from to_address parameter
    ; Format: to_address=!Addr1,!Addr2 or to_address=%21Addr1,%21Addr2 or %21Addr1%2C%21Addr2
    ; UPDATE THIS if Solscan changes their parameter name or format
    if RegExMatch(currentURL, "to_address=([^&]+)", &match) {
        excludeParam := match[1]

        ; URL decode common characters
        ; UPDATE THIS if Solscan changes encoding
        excludeParam := StrReplace(excludeParam, "%21", "!")  ; ! (exclamation)
        excludeParam := StrReplace(excludeParam, "%2C", ",")  ; , (comma)
        excludeParam := StrReplace(excludeParam, "%2c", ",")  ; , (comma lowercase)

        ; Split by comma to get individual exclusions
        ; UPDATE THIS if Solscan changes separator
        Loop Parse, excludeParam, ","
        {
            address := A_LoopField
            ; Remove the ! prefix
            ; UPDATE THIS if Solscan changes exclusion prefix
            if (SubStr(address, 1, 1) == "!") {
                address := SubStr(address, 2)
            }
            ; Validate and add to list
            if (address != "" && IsValidSolanaAddress(address)) {
                result.exclusions.Push(address)
            }
        }
    }

    return result
}

; ============================================================================
; Action: Open Solscan in Browser
; ============================================================================

OpenSolscan(address) {
    ; Custom Solscan URL with your preferred filters
    url := "https://solscan.io/account/" . address . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value=&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"
    Run url
}

; ============================================================================
; Action: Reload Page with Exclusions (URL-Based, Per-Tab Persistence)
; ============================================================================
; IMPORTANT: This function builds Solscan URLs with exclusion filters
;
; If Solscan changes their URL structure, update the following:
; - Line ~400: Parameter name "to_address"
; - Line ~392: Exclusion prefix "!"
; - Line ~389: Separator character ","
; - Line ~397-403: Base URL and all other parameters
; ============================================================================

ReloadPageWithExclusions(mainAddress, exclusionsList) {
    ; Build the exclusion parameter from the list
    ; Format: to_address=!Address1,!Address2,!Address3
    ; UPDATE THIS if Solscan changes format
    excludeParam := ""

    for index, excludeAddr in exclusionsList {
        if (excludeAddr != "") {
            if (excludeParam != "") {
                excludeParam .= ","  ; UPDATE THIS if separator changes
            }
            excludeParam .= "!" . excludeAddr  ; UPDATE THIS if prefix changes
        }
    }

    ; Build URL with exclusion filter
    ; UPDATE THIS entire URL structure if Solscan redesigns
    ; IMPORTANT: Match parameter order from OpenSolscan() to avoid Solscan parsing issues
    url := "https://solscan.io/account/" . mainAddress . "?activity_type=ACTIVITY_SPL_TRANSFER&exclude_amount_zero=true&remove_spam=true&value=100&value="

    ; Insert to_address BEFORE token_address (same as OpenSolscan)
    if (excludeParam != "") {
        url .= "&to_address=" . excludeParam  ; UPDATE THIS parameter name if changed
    }

    url .= "&token_address=So11111111111111111111111111111111111111111&page_size=10#transfers"

    ; Copy URL to clipboard
    A_Clipboard := url
    Sleep 100  ; Give clipboard time to update

    ; Focus browser and navigate to URL using address bar
    ; Ctrl+L selects address bar in most browsers
    Send "^l"
    Sleep 100
    ; Paste the URL
    Send "^v"
    Sleep 100
    ; Press Enter to navigate
    Send "{Enter}"
}

; ============================================================================
; Telegram Monitor: Register Address for Monitoring
; ============================================================================

HandleTelegramRegister() {
    ; Clear any pending clipboard operations
    A_Clipboard := ""

    ; Save original clipboard
    ClipSaved := ClipboardAll()

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; First, try to extract an address from the text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and register for monitoring
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to local monitoring service
            RegisterAddressWithMonitor(address)
        } else {
            ShowNotification("Invalid address", "Cannot register for monitoring")
        }
    } else {
        ShowNotification("No text captured", "Hover over an address and try again")
    }
}

RegisterAddressWithMonitor(address) {
    ; Build JSON payload
    jsonData := '{"address":"' . address . '","timestamp":"' . A_Now . '"}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_register.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to local server
    command := 'curl -X POST "' . LOCAL_SERVER_URL . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ShowNotification("Monitoring registered", address)
        } else {
            ShowNotification("Monitor service offline", "Start Python service first")
        }
    } catch {
        ShowNotification("Monitor service offline", "Start Python service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; Defined.fi Lookup: Open Token on defined.fi with Auto-Search
; ============================================================================

HandleDefinedFiLookup() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and open defined.fi
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Open defined.fi with hash parameter for UserScript to handle
            url := "https://defined.fi/#autosearch=" . address
            Run url
            ShowNotification("Opening defined.fi", address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

; ============================================================================
; Token Analysis: Analyze token for early bidders using Helius API
; ============================================================================

HandleTokenAnalysis() {
    ; Save original clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Try to capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard immediately
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Process captured text
    if (capturedText != "") {
        ; Extract address from text
        address := ExtractAddressFromText(capturedText)

        ; If extraction found nothing, check if the whole text is a valid address
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }

        ; Validate and analyze
        if (address != "" && IsValidSolanaAddress(address)) {
            ; Send to analysis service
            AnalyzeTokenWithService(address)
        } else {
            ShowNotification("Invalid token address", "Must be 32-44 character Solana address")
        }
    } else {
        ShowNotification("No text captured", "Hover over a token address and try again")
    }
}

AnalyzeTokenWithService(tokenAddress) {
    ; Fetch current API settings from backend
    settingsUrl := "http://localhost:5001/api/settings"

    ; Default settings (fallback)
    apiSettings := '{"transactionLimit":500,"minUsdFilter":50,"maxWalletsToStore":10,"apiRateDelay":100,"maxCreditsPerAnalysis":1000,"maxRetries":3}'

    ; Try to fetch settings using RunWait (more reliable than Exec)
    try {
        tempFile := A_Temp . "\api_settings.json"
        ; Delete temp file if it exists
        if FileExist(tempFile) {
            FileDelete(tempFile)
        }

        ; Use RunWait to fetch settings to temp file
        RunWait('curl -s "' . settingsUrl . '" -o "' . tempFile . '"', , "Hide")

        ; Read the temp file
        if FileExist(tempFile) {
            settingsResult := FileRead(tempFile)
            if (settingsResult != "" && InStr(settingsResult, "{")) {
                apiSettings := settingsResult
                ; Show a quick notification that settings were loaded
                ToolTip "Settings loaded from backend"
                SetTimer () => ToolTip(), -500
            }
            FileDelete(tempFile)
        }
    } catch as err {
        ; Use defaults if can't fetch settings
        ; (silent fallback - this is okay)
        ToolTip "Using default settings (backend offline?)"
        SetTimer () => ToolTip(), -1000
    }

    ; Build JSON payload with API settings
    jsonData := '{"address":"' . tokenAddress . '","api_settings":' . apiSettings . '}'

    ; Create temporary file for curl
    tempFile := A_Temp . "\solscan_analyze.json"
    try {
        FileDelete tempFile
    }
    FileAppend jsonData, tempFile

    ; Send POST request to analysis endpoint
    analysisUrl := "http://localhost:5001/analyze/token"
    command := 'curl -X POST "' . analysisUrl . '" -H "Content-Type: application/json" -d @"' . tempFile . '" 2>&1'

    try {
        result := RunWait('cmd /c ' . command, , "Hide")

        if (result = 0) {
            ; Show Windows notification for analysis started
            ShowNotification("Analysis Started", "Analyzing token: " . SubStr(tokenAddress, 1, 8) . "...")
            ; Also show a tooltip that persists for 3 seconds
            ToolTip "Token Analysis Running`nAddress: " . SubStr(tokenAddress, 1, 12) . "...`nCheck dashboard for results"
            SetTimer () => ToolTip(), -3000
        } else {
            ShowNotification("Analysis service offline", "Start monitor service first")
        }
    } catch {
        ShowNotification("Analysis service offline", "Start monitor service first")
    }

    ; Cleanup
    try {
        FileDelete tempFile
    }
}

; ============================================================================
; UI Feedback: Toast Notification
; ============================================================================

ShowNotification(title, message) {
    ; Show Windows notification
    TrayTip title, message, "Iconi Mute"
    ; Also show tooltip for redundancy
    ToolTip title . "`n" . message
    SetTimer () => ToolTip(), -NOTIFICATION_DURATION
}

; ============================================================================
; RADIAL PIE MENU SYSTEM (GDI+)
; ============================================================================
; Beautiful Blender-style radial pie menu using GDI+ for native rendering
;
; INTERACTION METHODS:
; - Mouse: Hover over slices to highlight, click to select
; - Keyboard: Press 1-6 to select action directly, Esc to cancel
;
; FEATURES:
; - Real-time mouse tracking with smooth hover detection
; - Dynamic highlighting of hovered slice
; - Separated ring-style slices with gaps (Blender-style)
; - Center selection ring indicator
; ============================================================================

global WheelMenuActive := false
global WheelMenuGui := ""
global WheelMenuHwnd := 0
global WheelMenuHdc := 0
global WheelMenuHbm := 0
global WheelMenuGraphics := 0
global WheelMenuCenterX := 0
global WheelMenuCenterY := 0
global WheelMenuOriginX := 0
global WheelMenuOriginY := 0
global WheelMenuSize := 300
global WheelMenuLastHovered := 0
global WheelMenuMouseAngle := 0  ; Current mouse angle for smooth highlight
global WheelMenuInitialized := false  ; Track if GUI has been pre-created

; ============================================================================
; Initialize Wheel Menu (Pre-create GUI for instant display)
; ============================================================================
; This runs once on script startup to create all GUI resources
; Subsequent menu openings just show/hide the pre-created window (instant!)
; ============================================================================

InitializeWheelMenu() {
    global WheelMenuGui, WheelMenuHwnd, WheelMenuHdc, WheelMenuHbm
    global WheelMenuGraphics, WheelMenuSize, WheelMenuInitialized

    if (WheelMenuInitialized) {
        return  ; Already initialized
    }

    ; Create fullscreen layered GUI window (hidden initially)
    WheelMenuGui := Gui("-Caption +E0x80000 +AlwaysOnTop +ToolWindow")
    WheelMenuHwnd := WheelMenuGui.Hwnd

    ; Create persistent GDI+ objects for rendering
    WheelMenuHbm := CreateDIBSection(WheelMenuSize, WheelMenuSize)
    if (!WheelMenuHbm) {
        MsgBox "Failed to create wheel menu bitmap!"
        return
    }

    WheelMenuHdc := CreateCompatibleDC()
    if (!WheelMenuHdc) {
        MsgBox "Failed to create wheel menu device context!"
        return
    }

    SelectObject(WheelMenuHdc, WheelMenuHbm)
    WheelMenuGraphics := Gdip_GraphicsFromHDC(WheelMenuHdc)
    if (!WheelMenuGraphics) {
        MsgBox "Failed to create wheel menu graphics!"
        return
    }

    Gdip_SetSmoothingMode(WheelMenuGraphics, 4)

    WheelMenuInitialized := true
}

ShowWheelMenu() {
    global WheelMenuActive, WheelMenuGui, WheelMenuHwnd, WheelMenuHdc, WheelMenuHbm
    global WheelMenuGraphics, WheelMenuCenterX, WheelMenuCenterY
    global WheelMenuOriginX, WheelMenuOriginY, WheelMenuSize, WheelMenuLastHovered
    global WheelMenuCapturedAddress, WheelMenuInitialized

    ; Ensure GUI is initialized (lazy initialization)
    if (!WheelMenuInitialized) {
        InitializeWheelMenu()
    }

    ; If menu is already open, just close it
    if (WheelMenuActive) {
        CloseWheelMenu()
        return
    }

    ; CRITICAL: Capture address BEFORE opening menu (before mouse moves away)
    ; Save clipboard
    ClipSaved := ClipboardAll()
    A_Clipboard := ""

    ; Capture text under cursor
    capturedText := CaptureTextUnderCursor()

    ; Restore clipboard
    A_Clipboard := ClipSaved
    ClipSaved := ""

    ; Extract and validate address
    WheelMenuCapturedAddress := ""
    if (capturedText != "") {
        address := ExtractAddressFromText(capturedText)
        if (address == "" && IsValidSolanaAddress(capturedText)) {
            address := capturedText
        }
        if (address != "" && IsValidSolanaAddress(address)) {
            WheelMenuCapturedAddress := address
        }
    }

    ; Debug: Show what was captured (comment out in production)
    ToolTip "Captured: " . WheelMenuCapturedAddress
    SetTimer () => ToolTip(), -1000

    ; Get mouse position for menu placement
    MouseGetPos &mx, &my
    WheelMenuOriginX := mx
    WheelMenuOriginY := my

    WheelMenuCenterX := WheelMenuSize // 2
    WheelMenuCenterY := WheelMenuSize // 2

    ; Show the pre-created GUI window (instant!)
    WheelMenuGui.Show("x0 y0 w" . A_ScreenWidth . " h" . A_ScreenHeight . " NoActivate")

    ; Initial draw
    WheelMenuLastHovered := 0
    RedrawWheelMenu(0)

    WheelMenuActive := true

    ; Start mouse tracking timer (60 FPS)
    SetTimer UpdateWheelMenuHover, 16

    ; Set up click handler
    OnMessage(0x201, WheelMenuClickHandler)
}

UpdateWheelMenuHover() {
    global WheelMenuActive, WheelMenuOriginX, WheelMenuOriginY
    global WheelMenuLastHovered

    if (!WheelMenuActive) {
        SetTimer UpdateWheelMenuHover, 0
        return
    }

    ; Get mouse position
    MouseGetPos &mx, &my

    ; Calculate relative position to menu center
    relX := mx - WheelMenuOriginX
    relY := my - WheelMenuOriginY

    ; Calculate distance from center
    dist := Sqrt(relX * relX + relY * relY)

    ; Determine hovered slice
    hoveredSlice := 0

    ; Blender-style behavior: Highlight based on angle if mouse is outside center dead zone
    ; This creates "cones of influence" that extend infinitely outward
    if (dist >= 20) {  ; Only need minimum distance from center (dead zone)
        ; Calculate angle (in degrees, 0 = right, 90 = down, 180 = left, 270 = up)
        ; Use ATan for y/x ratio, then adjust based on quadrant
        if (relX == 0) {
            angleRad := (relY > 0) ? 1.5707963267948966 : -1.5707963267948966  ; 90° or -90°
        } else {
            angleRad := ATan(relY / relX)
            ; Adjust for quadrant
            if (relX < 0) {
                angleRad += 3.14159265359  ; Add 180° for left half
            } else if (relY < 0) {
                angleRad += 6.28318530718  ; Add 360° for negative angles
            }
        }
        angleDeg := angleRad * 180 / 3.14159265359

        ; Normalize to 0-360
        if (angleDeg < 0) {
            angleDeg += 360
        }

        ; Adjust for our slice layout (first slice centered at top)
        angleDeg := Mod(angleDeg + 90, 360)

        ; Determine which slice (1-6) based purely on angle
        hoveredSlice := Floor(angleDeg / 60) + 1
        if (hoveredSlice > 6) {
            hoveredSlice := 1
        }
    }

    ; Redraw if hovered slice changed
    if (hoveredSlice != WheelMenuLastHovered) {
        WheelMenuLastHovered := hoveredSlice
        RedrawWheelMenu(hoveredSlice)
    }
}

RedrawWheelMenu(hoveredSlice) {
    global WheelMenuGraphics, WheelMenuHdc, WheelMenuHwnd
    global WheelMenuCenterX, WheelMenuCenterY, WheelMenuOriginX, WheelMenuOriginY
    global WheelMenuSize

    if (!WheelMenuGraphics) {
        return
    }

    centerX := WheelMenuCenterX
    centerY := WheelMenuCenterY
    outerRadius := 15      ; Larger ring for better visibility and hover accuracy
    innerRadius := 10      ; Larger inner radius to maintain proportions

    ; Clear canvas
    Gdip_GraphicsClear(WheelMenuGraphics, 0x00000000)

    ; Draw 6 thin ring segments with gaps
    Loop 6 {
        sliceIndex := A_Index
        startAngle := (sliceIndex - 1) * 60 - 90  ; slice 1 at north
        sweepAngle := 55  ; 55° slice + 5° gap = 60° total

        ; Determine color: grey normally, muted light blue when hovered
        if (sliceIndex == hoveredSlice) {
            color := 0xFF6B9BD1  ; Muted light blue when highlighted
        } else {
            color := 0xFF505050  ; Grey for all non-highlighted slices
        }

        ; Draw outer ring segment
        pBrush := Gdip_BrushCreateSolid(color)
        if (pBrush) {
            Gdip_FillPie(WheelMenuGraphics, pBrush
                , centerX - outerRadius, centerY - outerRadius
                , outerRadius * 2, outerRadius * 2, startAngle, sweepAngle)
            Gdip_DeleteBrush(pBrush)
        }
    }

    ; Cut out inner circle to make it a hollow ring
    ; Use compositing mode SourceCopy (1) to actually erase to transparency
    Gdip_SetCompositingMode(WheelMenuGraphics, 1)
    pBrushClear := Gdip_BrushCreateSolid(0x00000000)
    if (pBrushClear) {
        Gdip_FillEllipse(WheelMenuGraphics, pBrushClear
            , centerX - innerRadius, centerY - innerRadius
            , innerRadius * 2, innerRadius * 2)
        Gdip_DeleteBrush(pBrushClear)
    }
    ; Restore compositing mode to SourceOver (0) for normal drawing
    Gdip_SetCompositingMode(WheelMenuGraphics, 0)

    ; Draw text labels as floating boxes outside the ring
    ; Use dynamic labels from settings
    global WheelMenuActions
    labels := WheelMenuActions

    fontFamily := Gdip_CreateFontFamily("Inter")
    if (!fontFamily) {
        ; Fallback to Segoe UI if Inter not installed
        fontFamily := Gdip_CreateFontFamily("Segoe UI")
    }

    if (fontFamily) {
        font := Gdip_CreateFont(fontFamily, 8, 1)  ; Slightly larger font
        fontNumber := Gdip_CreateFont(fontFamily, 10, 0)  ; Smaller number, not bold

        if (font && fontNumber) {
            format := Gdip_CreateStringFormat(0, 0)
            if (format) {
                Gdip_SetStringFormatAlign(format, 1)      ; Center horizontally
                Gdip_SetStringFormatLineAlign(format, 1)  ; Center vertically

                textDistance := 55  ; Distance from center for text boxes

                Loop labels.Length {
                    sliceIndex := A_Index
                    angle := (sliceIndex - 1) * 60 - 90 + 27.5  ; Center of slice (+ half sweep for true center)
                    angleRad := angle * 3.14159265359 / 180

                    ; Calculate position for text box
                    textX := centerX + (textDistance * Cos(angleRad))
                    textY := centerY + (textDistance * Sin(angleRad))

                    ; Determine text colors (INVERTED: dark normally, grey when hovered)
                    if (sliceIndex == hoveredSlice) {
                        textColor := 0xFFFFFFFF      ; White text when hovered
                        bgColor := 0xFF505050        ; Grey background when hovered (fully opaque)
                    } else {
                        textColor := 0xFFCCCCCC      ; Light gray text normally
                        bgColor := 0xFF000000        ; Black background normally (fully opaque)
                    }

                    ; Create combined label with number (like "1 Solscan")
                    combinedLabel := sliceIndex . " " . labels[sliceIndex]

                    ; Draw rounded rectangle background for label
                    boxW := 50  ; Wider to fit number + text
                    boxH := 28   ; Slightly shorter since only one line
                    cornerRadius := 6  ; Slight rounding

                    pBrushBg := Gdip_BrushCreateSolid(bgColor)
                    if (pBrushBg) {
                        ; Create rounded rectangle path
                        path := Gdip_CreatePath()
                        if (path) {
                            Gdip_AddPathRoundedRectangle(path, textX - boxW/2, textY - boxH/2, boxW, boxH, cornerRadius)
                            Gdip_FillPath(WheelMenuGraphics, pBrushBg, path)
                            Gdip_DeletePath(path)
                        }
                        Gdip_DeleteBrush(pBrushBg)
                    }

                    ; Draw combined label text (number + label on same line)
                    pTextBrush := Gdip_BrushCreateSolid(textColor)
                    if (pTextBrush) {
                        Gdip_DrawString(WheelMenuGraphics, combinedLabel, font, pTextBrush
                            , textX - boxW/2, textY - boxH/2, boxW, boxH, format)
                        Gdip_DeleteBrush(pTextBrush)
                    }
                }

                Gdip_DeleteStringFormat(format)
            }
            if (font)
                Gdip_DeleteFont(font)
            if (fontNumber)
                Gdip_DeleteFont(fontNumber)
        }
        Gdip_DeleteFontFamily(fontFamily)
    }

    ; Update the layered window
    UpdateLayeredWindow(WheelMenuHwnd, WheelMenuHdc
        , WheelMenuOriginX - centerX, WheelMenuOriginY - centerY
        , WheelMenuSize, WheelMenuSize)
}

HandleMenuClick(*) {
    global WheelMenuLastHovered

    ; Execute action for currently hovered slice
    if (WheelMenuLastHovered > 0) {
        SelectWheelAction(WheelMenuLastHovered)
    } else {
        ; Click outside ring area (center or outside) - close menu
        CloseWheelMenu()
    }
}

WheelMenuClickHandler(wParam, lParam, msg, hwnd) {
    global WheelMenuActive, WheelMenuHwnd, WheelMenuLastHovered

    ; Check if click is on our menu window
    if (!WheelMenuActive || hwnd != WheelMenuHwnd) {
        return
    }

    ; Execute action for currently hovered slice
    if (WheelMenuLastHovered > 0) {
        SelectWheelAction(WheelMenuLastHovered)
    } else {
        ; Click outside ring area - close menu
        CloseWheelMenu()
    }

    return
}

SelectWheelAction(actionId) {
    global WheelMenuCapturedAddress, WheelMenuActions

    ; Close menu first
    CloseWheelMenu()

    ; Small delay
    Sleep 50

    ; Get the action name from configured actions
    actionName := WheelMenuActions[actionId]

    ; Handle "Cancel" action without needing an address
    if (actionName == "Cancel") {
        return
    }

    ; Check if we have a captured address for other actions
    if (WheelMenuCapturedAddress == "") {
        ShowNotification("No address captured", "Hover over an address before opening menu")
        return
    }

    ; Execute action based on configured action name
    switch actionName {
        case "Solscan":
            global currentMainAddress := WheelMenuCapturedAddress
            global excludedAddressesList := []
            OpenSolscan(WheelMenuCapturedAddress)
            ShowNotification("Opening Solscan...", WheelMenuCapturedAddress)
        case "Exclude":
            ; Get current URL data for exclusion
            urlData := GetAddressAndExclusionsFromURL()
            if (urlData.address != "") {
                ; Add captured address to exclusion list
                alreadyExcluded := false
                for index, addr in urlData.exclusions {
                    if (addr == WheelMenuCapturedAddress) {
                        alreadyExcluded := true
                        break
                    }
                }
                if (!alreadyExcluded) {
                    urlData.exclusions.Push(WheelMenuCapturedAddress)
                }
                ReloadPageWithExclusions(urlData.address, urlData.exclusions)
                ShowNotification("Excluded address added", WheelMenuCapturedAddress)
            } else {
                ShowNotification("No Solscan page detected", "Open a Solscan address page first")
            }
        case "Monitor":
            RegisterAddressWithMonitor(WheelMenuCapturedAddress)
        case "Defined.fi":
            url := "https://defined.fi/#autosearch=" . WheelMenuCapturedAddress
            Run url
            ShowNotification("Opening defined.fi", WheelMenuCapturedAddress)
        case "Analyze":
            AnalyzeTokenWithService(WheelMenuCapturedAddress)
        case "Cancel":
            return
    }
}

CloseWheelMenu() {
    global WheelMenuActive, WheelMenuGui
    global WheelMenuLastHovered

    if (!WheelMenuActive) {
        return
    }

    ; Stop timer first
    SetTimer UpdateWheelMenuHover, 0

    ; Remove click handler
    OnMessage(0x201, WheelMenuClickHandler, 0)

    WheelMenuActive := false
    WheelMenuLastHovered := 0

    ; Hide GUI (don't destroy - we'll reuse it next time!)
    if (WheelMenuGui) {
        try WheelMenuGui.Hide()
    }
}

; Conditional hotkeys - only active when menu is open
#HotIf WheelMenuActive
1::SelectWheelAction(1)
2::SelectWheelAction(2)
3::SelectWheelAction(3)
4::SelectWheelAction(4)
5::SelectWheelAction(5)
Escape::CloseWheelMenu()
#HotIf

; ============================================================================
; Exit Hotkey: Ctrl+Alt+Q to quit script
; ============================================================================

^!q:: {
    result := MsgBox("Are you sure you want to exit?", "Exit Solscan Hotkey", "YesNo")
    if (result = "Yes") {
        ExitApp
    }
}

; ============================================================================
; Tray Menu Customization
; ============================================================================

A_TrayMenu.Delete()
A_TrayMenu.Add("Settings...", ShowSettingsWindow)
A_TrayMenu.Add()  ; Separator
A_TrayMenu.Add("Reload Script", (*) => Reload())
A_TrayMenu.Add("Exit", (*) => ExitApp())
A_IconTip := "Solscan Hotkey Active`n" . WheelMenuHotkey . ": Radial Menu`n`nRight-click tray icon → Settings to customize"
